<?php

/**
 * ProcessWire Tag Parser Module
 *
 * Substitutes tags in a given text block with values from a context (or 
 * an array of contexts).
 *
 * Each context provider must be an instance of WireData. This means that 
 * almost any object from ProcessWire can be used by the parser to do 
 * substitutions.
 *
 * Given an input string such as: 
 *
 *   "Date: {datetime}\nUser: {name}\nIP:   {REMOTE_ADDR}"
 *
 * ...and a user object as context, you can get this as the result:
 *
 *   "Date: 12th September 2012
 *    User: ryan
 *    IP:   127.0.0.1"
 *
 * 
 * USAGE
 * -----
 *
 * Single context:
 *   $parser = $modules->get("TextformatterTagParser"); 
 *   $parser
 *     ->set('context', $user)
 *     ->format($string)
 *     ;
 *
 * Multiple contexts:
 *   $parser = $modules->get("TextformatterTagParser"); 
 *   $parser
 *     ->set('context', array('user'=>$user, 'page'=>$page) )
 *     ->format($string)
 *     ;
 *
 * When using multiple contexts your tags can specify the context
 * to use. For example, {page.name} is more specific than just {name}. If 
 * no context specifier is used in a tag then contexts will be searched 
 * for a match in the order in which they appear in the context array and
 * the first match will be used for the substitution.
 *
 * @copyright Copyright (c) 2012, Netcarver (https://github.com/netcarver)
 *
 */

class TextformatterTagParser extends Textformatter
{

	protected $data = array(
		'context' => array(),
		'encode'  => false,
	);


	public static function getModuleInfo() {
		return array(
			'title'     => 'Tag Parser', 
			'version'   => 90, 
			'summary'   => "Substitutes tags in a given text block with values from a context.",
			'permanent' => false,
			'singluar'  => false,
			'autoload'  => false,
			'author'    => 'Netcarver',
		); 
	}


	public function format(&$str) {
		if(empty($this->data['context'])) throw new WireException(_("No context provided for parsing input string."));
		$str = self::parseTags($str, $this->data['context'], $this->data['encode']);
		return $this;
	}



	/**
	 * Parse {tags} from any number of PW WireData objects or $_SERVER variables
	 *
	 * $str  is the template to be parsed for {tags}
	 * $objs can be a single WireData object or an array of WireData objects from which {tags} will be substituted
	 */
	public static function parseTags($str, $objs, $urlencode = false) {

		if(strpos($str, '{') === false) return $str; 
		if(!preg_match_all('/\{([-_a-z0-9.|]+)\}/i', $str, $matches)) return $str;

		if($objs instanceof WireData) $objs = array( $objs );

		foreach($matches[1] as $key => $tag) {

			list( $tag, $specifier, $xform ) = self::splitTag($tag);

			// If no substitute can be found, the tag will remain unchanged.
			$value = $tag;

			if($tag == 'datetime') {
				$value = date(wire()->config->dateFormat);

			} else if(isset($_SERVER[$tag])) {
				$value = wire()->sanitizer->text($_SERVER[$tag]); 

			} else if(is_array($objs) && !empty($objs)) {

				$found = false;

				/** 
				 * We will search for $tag in the array of WireData objects.
				 *
				 * Does the tag have a specifier? 
				 * The tag {user.name} calls for the name parameter from the WireData object indexed as 'user' in the $objs array
				 */
				if($specifier) {
					$o = @$objs[ $specifier ];
					if($o instanceof WireData) {
						$temp = $o->get($tag);
						if(isset($temp)) {
							$value = (string) $temp;
							$found = true;
						}
					}
				}

				if(!$found) {
					// Search through the array. First hit will be used as the value for the tag
					foreach($objs as $o) {
						if(!($o instanceof WireData)) continue;		
						$temp = $o->get($tag);
						if(isset($temp)) {
							$value = (string) $temp;
							$found = true;
							break;
						}
					}
				}

				if($found && ('' != $xform))
					$value = self::xformValue($value, $xform);
			}

			if($urlencode) $value = urlencode($value);

			$str = str_replace($matches[0][$key], $value, $str); 	
		}

		return $str; 
	}


	/**
	 * Split the tag into possible parts...
	 *
	 * {specifier.field|xform}
	 *
	 **/
	protected static function splitTag($tag_in) {

		$tag       = $tag_in;
		$specifier = '';
		$xform     = '';

		$tag_parts = explode( '.', $tag_in );
		$n = count( $tag_parts );
		if (2==$n) {
			$specifier = $tag_parts[0];
			$tag       = $tag_parts[1];
		}

		$tag_parts = explode( '|', $tag );
		$n = count( $tag_parts );
		if (2==$n) {
			$tag   = $tag_parts[0]; 
			$xform = strtolower($tag_parts[1]);
		}

		$result = array( $tag, $specifier, $xform );
		return $result;
	}


	/**
	 * Allows a limited set of transformations to be applied to the input
	 **/
	protected static function xformValue($in, $xform) {

		$result = $in;
		switch($xform) {
		case "lower" :
			$result = mb_strtolower($in);
			break;
		case "upper" :
			$result = mb_strtoupper($in);
			break;
		case "title" :
			$result = mb_convert_case($in, MB_CASE_TITLE, "UTF-8");
			break;
		case "url" :
			$result = urlencode($in);
			break;
		default:
			break;
		}

		return $result;
	}


	public function get($key) {
		return isset($this->data[$key]) ? $this->data[$key] : null;
	}

	public function set($key, $value) {
		$this->data[$key] = $value;
		return $this;
	}

}

