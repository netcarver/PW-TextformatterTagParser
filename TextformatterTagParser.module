<?php

/**
 * ProcessWire Tag Parser Module
 *
 * Substitutes tags in a given text block with values from a context (or 
 * an array of contexts).
 *
 * Each context provider must be an instance of WireData. This means that 
 * almost any object from ProcessWire can be used by the parser to do 
 * substitutions.
 *
 * Given an input string such as: 
 *
 *   "Date: {datetime}\nUser: {name}\nIP:   {REMOTE_ADDR}"
 *
 * ...and a user object as context, you can get this as the result:
 *
 *   "Date: 12th September 2012
 *    User: ryan
 *    IP:   127.0.0.1"
 *
 * 
 * USAGE
 * -----
 *
 * Single context:
 *   $parser = $modules->get("TextformatterTagParser"); 
 *   $parser
 *     ->set('context', $user)
 *     ->format($string)
 *     ;
 *
 * Multiple contexts:
 *   $parser = $modules->get("TextformatterTagParser"); 
 *   $parser
 *     ->set('context', array('user'=>$user, 'page'=>$page) )
 *     ->format($string)
 *     ;
 *
 * When using multiple contexts your tags can specify the context
 * to use. For example, {page.name} is more specific than just {name}. If 
 * no context specifier is used in a tag then contexts will be searched 
 * for a match in the order in which they appear in the context array and
 * the first match will be used for the substitution.
 *
 * @copyright Copyright (c) 2012, Netcarver (https://github.com/netcarver)
 *
 */

class TextformatterTagParser extends Textformatter
{

	protected $data = array(
		'context' => array(),
		'encode'  => false,
	);


	public static function getModuleInfo() {
		return array(
			'title'     => 'Tag Parser', 
			'version'   => 110, 
			'summary'   => "Substitutes tags in a given text block with values from a context.",
			'permanent' => false,
			'singluar'  => false,
			'autoload'  => false,
			'author'    => 'Netcarver',
		); 
	}


	/**
	 * Format the input string
	 *
	 * @param string $str The block of text, with embedded tags, to parse
	 *
	 * The incoming string is replaced with the formatted version of itself.
	 **/
	public function format(&$str) {
		if(empty($this->data['context'])) throw new WireException(_("No context provided for parsing input string."));
		$str = self::parseTags($str, $this->data['context'], $this->data['encode']);
		return $this;
	}



	/**
	 * Parse {tags} from any number of PW WireData objects or $_SERVER variables
	 *
	 * @param string $str The template (block of text) to be parsed for {tags}
	 * @param array|WireData $objs This can be a single WireData object or an array of WireData objects from which {tags} will be substituted
	 * @param bool $urlencode Determines if urlencoding should be applied to every value substituted into the input text
	 * @return string The template with tags replaced by (possibly transformed) values from the given contexts
	 *
	 */
	public static function parseTags($str, $objs, $urlencode = false) {

		if(strpos($str, '{') === false) return $str; 
		if(!preg_match_all('/\{([-_a-z0-9.|>]+)\}/i', $str, $matches)) return $str;

		if($objs instanceof WireData) $objs = array( $objs );

		foreach($matches[1] as $key => $tag) {

			list( $tag, $specifier, $xforms ) = self::splitTag($tag);

			// If no substitute can be found, the tag will remain unchanged.
			$value = $tag;

			if($tag == 'datetime') {
				$value = date(wire()->config->dateFormat);

			} else if(isset($_SERVER[$tag])) {
				$value = wire()->sanitizer->text($_SERVER[$tag]); 

			} else if(is_array($objs) && !empty($objs)) {

				$found = false;

				/** 
				 * We will search for $tag in the array of WireData objects.
				 *
				 * Does the tag have a specifier? 
				 * The tag {user.name} calls for the name parameter from the WireData object indexed as 'user' in the $objs array
				 */
				if($specifier) {
					$o = @$objs[ $specifier ];
					if($o instanceof WireData) {
						$temp = $o->get($tag);
						if(isset($temp)) {
							$value = (string) $temp;
							$found = true;
						}
					}
				}

				if(!$found) {
					// Search through the array. First hit will be used as the value for the tag
					foreach($objs as $o) {
						if(!($o instanceof WireData)) continue;		
						$temp = $o->get($tag);
						if(isset($temp)) {
							$value = (string) $temp;
							$found = true;
							break;
						}
					}
				}

				if($found && !empty($xforms))
					$value = self::xformValue($value, $xforms, $urlencode);
			}

			if($urlencode) $value = urlencode($value);

			$str = str_replace($matches[0][$key], $value, $str); 	
		}

		return $str; 
	}


	/**
	 * Split the tag into possible parts...
	 *
	 * {specifier.field|xform}
	 *
	 * @param  string $tag_in The contents of the tag as found between the '{' ... '}' chars
	 * @return array  Contains the actual fieldname, the context specifier and an array (possibly empty) of transformation names
	 *
	 **/
	protected static function splitTag($tag_in) {

		$tag       = $tag_in;
		$specifier = '';
		$xform     = '';

		$tag_parts = explode( '.', $tag_in );
		$n = count( $tag_parts );
		if (2==$n) {
			$specifier = $tag_parts[0];
			$tag       = $tag_parts[1];
		}

		$tag_parts = explode( '>', $tag );
		$tag = array_shift($tag_parts); 
		$xform = $tag_parts;

		$result = array( $tag, $specifier, $xform );
		return $result;
	}


	/**
	 * Allows a set of transformations to be applied to the input
	 *
	 * @param  string $in The value to be transformed
	 * @param  array  $xforms An array of transformation names to be applied to $in
	 * @param  bool   $global_urlencode If true, stops any specific url transform from being applied (and thus having the value encoded twice)
	 * @return string The transformed version of $in (if any transformation needed)
	 **/
	protected static function xformValue($in, $xforms, $global_urlencode=false) {

		$result = $in;

		while(!empty($xforms)) {
			$xform = strtolower(array_shift($xforms));
			switch($xform) {
			case "lower" :
				$result = mb_strtolower($result);
				break;
			case "upper" :
				$result = mb_strtoupper($result);
				break;
			case "title" :
				$result = mb_convert_case($result, MB_CASE_TITLE, "UTF-8");
				break;
			case "url" :
				if(!$global_urlencode) $result = urlencode($result);
				break;
			case "strip" :
				$result = strip_tags($result);
				break;
			case "base64" :
				$result = base64_encode($result);
				break;
			default:
				break;
			}
		}

		return $result;
	}


	public function get($key) {
		return isset($this->data[$key]) ? $this->data[$key] : null;
	}

	public function set($key, $value) {
		$this->data[$key] = $value;
		return $this;
	}

}

